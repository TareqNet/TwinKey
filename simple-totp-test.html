<!DOCTYPE html>
<html>
<head>
    <title>Simple TOTP Test</title>
</head>
<body>
    <h1>Simple TOTP Test</h1>
    <input type="text" id="secret" placeholder="Enter secret" value="GEZDGNBVGY3TQOJQGEZDGNBVGY3TQOJQ">
    <button onclick="testWithCrypto()">Test with Web Crypto</button>
    <div id="result"></div>

    <script>
        // Simple TOTP using Web Crypto API
        async function testWithCrypto() {
            const secret = document.getElementById('secret').value.trim();
            
            try {
                // Decode base32
                const key = base32ToBytes(secret);
                
                // Get current time counter
                const time = Math.floor(Date.now() / 1000);
                const counter = Math.floor(time / 30);
                
                // Convert counter to 8 bytes
                const counterBytes = new ArrayBuffer(8);
                const counterView = new DataView(counterBytes);
                counterView.setUint32(4, counter, false); // big-endian, high bits are 0
                
                // Import key for HMAC-SHA1
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    key,
                    { name: 'HMAC', hash: 'SHA-1' },
                    false,
                    ['sign']
                );
                
                // Generate HMAC
                const hmac = await crypto.subtle.sign('HMAC', cryptoKey, counterBytes);
                const hmacBytes = new Uint8Array(hmac);
                
                // Dynamic truncation
                const offset = hmacBytes[19] & 0x0f;
                const code = ((hmacBytes[offset] & 0x7f) << 24) |
                            ((hmacBytes[offset + 1] & 0xff) << 16) |
                            ((hmacBytes[offset + 2] & 0xff) << 8) |
                            (hmacBytes[offset + 3] & 0xff);
                
                const otp = (code % 1000000).toString().padStart(6, '0');
                
                document.getElementById('result').innerHTML = `
                    <p>Secret: ${secret}</p>
                    <p>Time: ${time}</p>
                    <p>Counter: ${counter}</p>
                    <p>OTP: <strong>${otp}</strong></p>
                    <p>Time remaining: ${30 - (time % 30)} seconds</p>
                `;
                
                // Test RFC vectors
                await testRFCVectors();
                
            } catch (error) {
                document.getElementById('result').innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
            }
        }
        
        async function testRFCVectors() {
            const testCases = [
                { secret: 'GEZDGNBVGY3TQOJQGEZDGNBVGY3TQOJQ', time: 1111111109, expected: '081804' },
                { secret: 'GEZDGNBVGY3TQOJQGEZDGNBVGY3TQOJQ', time: 1234567890, expected: '005924' },
                { secret: 'GEZDGNBVGY3TQOJQGEZDGNBVGY3TQOJQ', time: 2000000000, expected: '279037' }
            ];
            
            let rfcResults = '<h3>RFC Test Results:</h3>';
            
            for (const test of testCases) {
                try {
                    const key = base32ToBytes(test.secret);
                    const counter = Math.floor(test.time / 30);
                    
                    const counterBytes = new ArrayBuffer(8);
                    const counterView = new DataView(counterBytes);
                    counterView.setUint32(4, counter, false);
                    
                    const cryptoKey = await crypto.subtle.importKey(
                        'raw', key, { name: 'HMAC', hash: 'SHA-1' }, false, ['sign']
                    );
                    
                    const hmac = await crypto.subtle.sign('HMAC', cryptoKey, counterBytes);
                    const hmacBytes = new Uint8Array(hmac);
                    
                    const offset = hmacBytes[19] & 0x0f;
                    const code = ((hmacBytes[offset] & 0x7f) << 24) |
                                ((hmacBytes[offset + 1] & 0xff) << 16) |
                                ((hmacBytes[offset + 2] & 0xff) << 8) |
                                (hmacBytes[offset + 3] & 0xff);
                    
                    const otp = (code % 1000000).toString().padStart(6, '0');
                    const match = otp === test.expected;
                    
                    rfcResults += `<p style="color: ${match ? 'green' : 'red'};">
                        Time: ${test.time} | Expected: ${test.expected} | Got: ${otp} ${match ? '✓' : '✗'}
                    </p>`;
                } catch (error) {
                    rfcResults += `<p style="color: red;">Error testing ${test.time}: ${error.message}</p>`;
                }
            }
            
            document.getElementById('result').innerHTML += rfcResults;
        }
        
        function base32ToBytes(base32) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            base32 = base32.replace(/\s+/g, '').replace(/=+$/, '').toUpperCase();
            
            let bits = 0;
            let value = 0;
            const output = [];
            
            for (let i = 0; i < base32.length; i++) {
                const char = base32[i];
                const index = alphabet.indexOf(char);
                if (index === -1) {
                    throw new Error(`Invalid base32 character: ${char}`);
                }
                
                value = (value << 5) | index;
                bits += 5;
                
                if (bits >= 8) {
                    output.push((value >>> (bits - 8)) & 255);
                    bits -= 8;
                }
            }
            
            return new Uint8Array(output);
        }
        
        // Auto test on load
        window.onload = () => testWithCrypto();
    </script>
</body>
</html>